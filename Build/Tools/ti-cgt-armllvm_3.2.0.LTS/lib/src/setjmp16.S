//******************************************************************************
//* SETJMP - 16 BIT STATE -  v#####                                            *
//* Copyright (c) 1996@%%%% Texas Instruments Incorporated                     *
//******************************************************************************

//****************************************************************************
//*   setjmp
//*
//*     C syntax  : int setjmp(jmp_buf env)
//*
//*     Function  : Save callers current environment for a subsequent
//*                 call to longjmp.  Return 0.
//*
//*     The context save area is organized as follows:
//*
//*       env -->  .long  V1
//*                .long  V2
//*                .long  V3
//*                .long  V4
//*                .long  V5
//*                .long  V6
//*                .long  V7
//*                .long  V8
//*                .long  SP
//*                .long  LR
//*
//****************************************************************************
//*
//*  NOTE : ANSI specifies that "setjmp.h" declare "setjmp" as a macro.
//*
//*         In the TIABI implementation, the setjmp macro calls a function
//*         "_setjmp".  However, since the user may not include "setjmp.h",
//*         we provide two entry-points to this function.
//*
//*         In the EABI implementation, the setjmp macro calls a function
//*         "setjmp".  No alternate entry point is provided.
//*
//*         (Note: Due to the incorrect definition of the "setjmp" macro
//*         introduced in 4.4.x [CQ24877], object files generated by the TI
//*         compiler for modules which call setjmp in EABI mode refer to a
//*         symbol named "_setjmp".  For this reason, we must leave in the
//*         alternate entry point for EABI mode.  The alternate entry point
//*         should be removed in 5.x)
//*
//****************************************************************************

        .section .text:setjmp, "ax", %progbits
        .global setjmp
        .thumb_func
setjmp: .asmfunc stack_usage(0)
	STMIA	A1!, {V1, V2, V3, V4}
	MOV	A2, V5
	MOV	A3, V6
	MOV	A4, V7
	MOV	V1, V8
	MOV	V2, SP
	MOV	V3, LR
	STMIA	A1!, {A2, A3, A4, V1, V2, V3}
	SUBS	A1, #40
	LDMIA	A1!, {V1, V2, V3, V4}
	MOVS    A1,#0
	BX	LR
	.endasmfunc

//****************************************************************************
//*   longjmp
//*
//*     C syntax  : void longjmp(jmp_buf env, int val)
//*
//*     Function  : Restore the context contained in the jump buffer.
//*                 This causes an apparent "2nd return" from the
//*                 setjmp invocation which built the "env" buffer.
//*                 This return appears to return "returnvalue".
//*                 NOTE: This function may not return 0.
//****************************************************************************
        .section .text:longjmp, "ax", %progbits
	.global longjmp
	.thumb_func
longjmp: .asmfunc stack_usage(0)
	ADDS	A1, #16
	LDMIA	A1!, {A3, A4, V1, V2, V3, V4}
	MOV	V5, A3
	MOV	V6, A4
	MOV	V7, V1
	MOV	V8, V2
	MOV	SP, V3
	MOV     LR, V4
	SUBS	A1, #40
	LDMIA	A1!, {V1, V2, V3, V4}
	CMP	A2, #0
	BNE	_ct_
	MOVS	A2, #1
_ct_:	MOVS	A1, A2
	BX	LR
	.endasmfunc
