//******************************************************************************
//* SETJMP - 32 BIT STATE -  v#####                                            *
//* Copyright (c) 1996@%%%% Texas Instruments Incorporated                     *
//******************************************************************************

//****************************************************************************
//*   setjmp
//*
//*     C syntax  : int setjmp(jmp_buf env)
//*
//*     Function  : Save callers current environment for a subsequent
//*                 call to longjmp.  Return 0.
//*
//*     The context save area is organized as follows:
//*
//*       env -->  .long  V1
//*                .long  V2
//*                .long  V3
//*                .long  V4
//*                .long  V5
//*                .long  V6
//*                .long  V7
//*                .long  V8
//*                .long  SP
//*                .long  LR
//*
//****************************************************************************
//*
//*  NOTE : ANSI specifies that "setjmp.h" declare "setjmp" as a macro.
//*
//*         In the TIABI implementation, the setjmp macro calls a function
//*         "_setjmp".  However, since the user may not include "setjmp.h",
//*         we provide two entry-points to this function.
//*
//*         In the EABI implementation, the setjmp macro calls a function
//*         "setjmp".  No alternate entry point is provided.
//*
//*         (Note: Due to the incorrect definition of the "setjmp" macro
//*         introduced in 4.4.x [CQ24877], object files generated by the TI
//*         compiler for modules which call setjmp in EABI mode refer to a
//*         symbol named "_setjmp".  For this reason, we must leave in the
//*         alternate entry point for EABI mode.  The alternate entry point
//*         should be removed in 5.x)
//*
//****************************************************************************

        .section .text:setjmp, "ax", %progbits
        .p2align 2
        .global setjmp
        .type   setjmp,%function
        .arm
setjmp: .asmfunc stack_usage(0)
	STMIA	A1!, {V1 - V8, LR}
        STR     SP, [A1], #4
	#ifdef __ARM_FP
	VSTMIA	A1!, {D8 - D15}
        #endif
	MOV     A1,#0
	BX	LR
       	.endasmfunc

//****************************************************************************
//*   longjmp
//*
//*     C syntax  : void longjmp(jmp_buf env, int val)
//*
//*     Function  : Restore the context contained in the jump buffer.
//*                 This causes an apparent "2nd return" from the
//*                 setjmp invocation which built the "env" buffer.
//*                 This return appears to return "returnvalue".
//*                 NOTE: This function may not return 0.
//****************************************************************************

        .section .text:longjmp, "ax", %progbits
	.global longjmp
longjmp: .asmfunc stack_usage(0)
	LDMIA	A1!, {V1 - V8, LR}
        LDR     SP, [A1], #4
        #ifdef __ARM_FP
	VLDMIA	A1!, {D8 - D15}
        #endif
	CMP	A2, #0
	MOVEQ	A1, #1
	MOVNE	A1, A2
	BX	LR
	.endasmfunc
